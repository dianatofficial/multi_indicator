// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © https://sites.google.com/view/dianatofficial/
// © https://github.com/dianatofficial


//@version=5
indicator(title="bof + srch + sslh", shorttitle="bof + srch + sslh", overlay=true)
//_________________Envelope_________________




prdbof = input.int(defval=5, title='Period', minval=2)
bo_lenbof = input.int(defval=200, title='Max Breakout Length', minval=30, maxval=300)
cwidthu = input.float(defval=3., title='Threshold Rate %', minval=1., maxval=10) / 100
mintest = input.int(defval=2, title='Minimum Number of Tests', minval=1)
bocolorup = input.color(defval=color.blue, title='Breakout Colors', inline='bocol')
bocolordown = input.color(defval=color.red, title='', inline='bocol')
lstyle = input.string(defval=line.style_solid, title='Line Style', options=[line.style_solid, line.style_dashed, line.style_dotted])
lineWidth = input.int(defval=1, title="Line Width", minval=1, maxval=5)
areaColorUp = input.color(defval=color.new(color.blue, 90), title="Bullish Area Color")
areaColorDown = input.color(defval=color.new(color.red, 90), title="Bearish Area Color")


//width
lll = math.max(math.min(bar_index, 300), 1)
float h_ = ta.highest(lll)
float l_ = ta.lowest(lll)
float chwidth = (h_ - l_) * cwidthu

// check if PH/PL
phbof = ta.pivothigh(prdbof, prdbof)
plbof = ta.pivotlow(prdbof, prdbof)

//keep Pivot Points and their locations in the arrays
var phvalbof = array.new_float(0)
var phlocbof = array.new_int(0)
var plvalbof = array.new_float(0)
var pllocbof = array.new_int(0)

// keep PH/PL levels and locations
if phbof
    array.unshift(phvalbof, phbof)
    array.unshift(phlocbof, bar_index - prdbof)
    if array.size(phvalbof) > 1  // cleanup old ones
        for x = array.size(phlocbof) - 1 to 1 by 1
            if bar_index - array.get(phlocbof, x) > bo_lenbof
                array.pop(phlocbof)
                array.pop(phvalbof)

if plbof
    array.unshift(plvalbof, plbof)
    array.unshift(pllocbof, bar_index - prdbof)
    if array.size(plvalbof) > 1  // cleanup old ones
        for x = array.size(pllocbof) - 1 to 1 by 1
            if bar_index - array.get(pllocbof, x) > bo_lenbof
                array.pop(pllocbof)
                array.pop(plvalbof)

// check bullish cup
float bomax = na
int bostart = bar_index
numbof = 0
hgst = ta.highest(prdbof)[1]
if array.size(phvalbof) >= mintest and close > open and close > hgst
    bomax := array.get(phvalbof, 0)
    xx = 0
    for x = 0 to array.size(phvalbof) - 1 by 1
        if array.get(phvalbof, x) >= close
            break
        xx := x
        bomax := math.max(bomax, array.get(phvalbof, x))
        bomax
    if xx >= mintest and open <= bomax
        for x = 0 to xx by 1
            if array.get(phvalbof, x) <= bomax and array.get(phvalbof, x) >= bomax - chwidth
                numbof += 1
                bostart := array.get(phlocbof, x)
                bostart
        if numbof < mintest or hgst >= bomax
            bomax := na
            bomax

if not na(bomax) and numbof >= mintest
    line.new(x1=bar_index, y1=bomax, x2=bostart, y2=bomax, color=bocolorup, style=lstyle)
    line.new(x1=bar_index, y1=bomax - chwidth, x2=bostart, y2=bomax - chwidth, color=bocolorup, style=lstyle)
    line.new(x1=bostart, y1=bomax - chwidth, x2=bostart, y2=bomax, color=bocolorup, style=lstyle)
    line.new(x1=bar_index, y1=bomax - chwidth, x2=bar_index, y2=bomax, color=bocolorup, style=lstyle)

plotshape(not na(bomax) and numbof >= mintest, location=location.belowbar, style=shape.triangleup, color=bocolorup, size=size.small)
alertcondition(not na(bomax) and numbof >= mintest, title='Breakout', message='Breakout')



// check bearish cup
float bomin = na
bostart := bar_index
num1bof = 0
lwst = ta.lowest(prdbof)[1]
if array.size(plvalbof) >= mintest and close < open and close < lwst
    bomin := array.get(plvalbof, 0)
    xx = 0
    for x = 0 to array.size(plvalbof) - 1 by 1
        if array.get(plvalbof, x) <= close
            break
        xx := x
        bomin := math.min(bomin, array.get(plvalbof, x))
        bomin
    if xx >= mintest and open >= bomin
        for x = 0 to xx by 1
            if array.get(plvalbof, x) >= bomin and array.get(plvalbof, x) <= bomin + chwidth
                num1bof += 1
                bostart := array.get(pllocbof, x)
                bostart
        if num1bof < mintest or lwst <= bomin
            bomin := na
            bomin

if not na(bomin) and num1bof >= mintest
    line.new(x1=bar_index, y1=bomin, x2=bostart, y2=bomin, color=bocolordown, style=lstyle)
    line.new(x1=bar_index, y1=bomin + chwidth, x2=bostart, y2=bomin + chwidth, color=bocolordown, style=lstyle)
    line.new(x1=bostart, y1=bomin + chwidth, x2=bostart, y2=bomin, color=bocolordown, style=lstyle)
    line.new(x1=bar_index, y1=bomin + chwidth, x2=bar_index, y2=bomin, color=bocolordown, style=lstyle)

plotshape(not na(bomin) and num1bof >= mintest, location=location.abovebar, style=shape.triangledown, color=bocolordown, size=size.small)

alertcondition(not na(bomin) and num1bof >= mintest, title='Breakdown', message='Breakdown')
alertcondition(not na(bomax) and numbof >= mintest or not na(bomin) and num1bof >= mintest, title='Breakout or Breakdown', message='Breakout or Breakdown')





//
//
//
//
//
//
//

prd = input.int(defval=10, title='Pivot Period', minval=4, maxval=30, group='Settings 🔨', tooltip='Used while calculating Pivot Points, checks left&right bars')
ppsrc = input.string(defval='High/Low', title='Source', options=['High/Low', 'Close/Open'], group='Settings 🔨', tooltip='Source for Pivot Points')
ChannelW = input.int(defval=5, title='Maximum Channel Width %', minval=1, maxval=8, group='Settings 🔨', tooltip='Calculated using Highest/Lowest levels in 300 bars')
minstrength = input.int(defval=1, title='Minimum Strength', minval=1, group='Settings 🔨', tooltip='Channel must contain at least 2 Pivot Points')
maxnumsr = input.int(defval=6, title='Maximum Number of S/R', minval=1, maxval=10, group='Settings 🔨', tooltip='Maximum number of Support/Resistance Channels to Show') - 1
loopback = input.int(defval=290, title='Loopback Period', minval=100, maxval=400, group='Settings 🔨', tooltip='While calculating S/R levels it checks Pivots in Loopback Period')
res_col = input.color(defval=color.new(color.red, 75), title='Resistance Color', group='Colors 🟡🟢🟣')
sup_col = input.color(defval=color.new(color.lime, 75), title='Support Color', group='Colors 🟡🟢🟣')
inch_col = input.color(defval=color.new(color.gray, 75), title='Color When Price in Channel', group='Colors 🟡🟢🟣')
showpp = input.bool(defval=false, title='Show Pivot Points', group='Extras ⏶⏷')
showsrbroken = input.bool(defval=false, title='Show Broken Support/Resistance', group='Extras ⏶⏷')
showthema1en = input.bool(defval=false, title='MA 1', inline='ma1')
showthema1len = input.int(defval=50, title='', inline='ma1')
showthema1type = input.string(defval='SMA', title='', options=['SMA', 'EMA'], inline='ma1')
showthema2en = input.bool(defval=false, title='MA 2', inline='ma2')
showthema2len = input.int(defval=200, title='', inline='ma2')
showthema2type = input.string(defval='SMA', title='', options=['SMA', 'EMA'], inline='ma2')

ma1 = showthema1en ? showthema1type == 'SMA' ? ta.sma(close, showthema1len) : ta.ema(close, showthema1len) : na
ma2 = showthema2en ? showthema2type == 'SMA' ? ta.sma(close, showthema2len) : ta.ema(close, showthema2len) : na

plot(ma1, color=not na(ma1) ? color.blue : na)
plot(ma2, color=not na(ma2) ? color.red : na)

// get Pivot High/low
float src1 = ppsrc == 'High/Low' ? high : math.max(close, open)
float src2 = ppsrc == 'High/Low' ? low : math.min(close, open)
float ph = ta.pivothigh(src1, prd, prd)
float pl = ta.pivotlow(src2, prd, prd)

// draw Pivot points
plotshape(ph and showpp, text='H', style=shape.labeldown, color=na, textcolor=color.new(color.red, 0), location=location.abovebar, offset=-prd)
plotshape(pl and showpp, text='L', style=shape.labelup, color=na, textcolor=color.new(color.lime, 0), location=location.belowbar, offset=-prd)

//calculate maximum S/R channel width
prdhighest = ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

// get/keep Pivot levels
var pivotvals = array.new_float(0)
var pivotlocs = array.new_float(0)
if ph or pl
    array.unshift(pivotvals, ph ? ph : pl)
    array.unshift(pivotlocs, bar_index)
    for x = array.size(pivotvals) - 1 to 0 by 1
        if bar_index - array.get(pivotlocs, x) > loopback  // remove old pivot points
            array.pop(pivotvals)
            array.pop(pivotlocs)
            continue
        break

//find/create SR channel of a pivot point
get_sr_vals(ind) =>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1 by 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= hi ? hi - cpp : cpp - lo
        if wdth <= cwidth  // fits the max channel width?
            if cpp <= hi
                lo := math.min(lo, cpp)
                lo
            else
                hi := math.max(hi, cpp)
                hi

            numpp += 20  // each pivot point added as 20
            numpp
    [hi, lo, numpp]

// keep old SR channels and calculate/sort new channels if we met new pivot point
var suportresistance = array.new_float(20, 0)  // min/max levels
changeit(x, y) =>
    tmp = array.get(suportresistance, y * 2)
    array.set(suportresistance, y * 2, array.get(suportresistance, x * 2))
    array.set(suportresistance, x * 2, tmp)
    tmp := array.get(suportresistance, y * 2 + 1)
    array.set(suportresistance, y * 2 + 1, array.get(suportresistance, x * 2 + 1))
    array.set(suportresistance, x * 2 + 1, tmp)

if ph or pl
    supres = array.new_float(0)  // number of pivot, strength, min/max levels
    stren = array.new_float(10, 0)
    // get levels and strengs
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        array.push(supres, strength)
        array.push(supres, hi)
        array.push(supres, lo)

    // add each HL to strengh
    for x = 0 to array.size(pivotvals) - 1 by 1
        h = array.get(supres, x * 3 + 1)
        l = array.get(supres, x * 3 + 2)
        s = 0
        for y = 0 to loopback by 1
            if high[y] <= h and high[y] >= l or low[y] <= h and low[y] >= l
                s += 1
                s
        array.set(supres, x * 3, array.get(supres, x * 3) + s)

    //reset SR levels
    array.fill(suportresistance, 0)
    // get strongest SRs
    src = 0
    for x = 0 to array.size(pivotvals) - 1 by 1
        stv = -1.  // value
        stl = -1  // location
        for y = 0 to array.size(pivotvals) - 1 by 1
            if array.get(supres, y * 3) > stv and array.get(supres, y * 3) >= minstrength * 20
                stv := array.get(supres, y * 3)
                stl := y
                stl
        if stl >= 0
            //get sr level
            hh = array.get(supres, stl * 3 + 1)
            ll = array.get(supres, stl * 3 + 2)
            array.set(suportresistance, src * 2, hh)
            array.set(suportresistance, src * 2 + 1, ll)
            array.set(stren, src, array.get(supres, stl * 3))

            // make included pivot points' strength zero 
            for y = 0 to array.size(pivotvals) - 1 by 1
                if array.get(supres, y * 3 + 1) <= hh and array.get(supres, y * 3 + 1) >= ll or array.get(supres, y * 3 + 2) <= hh and array.get(supres, y * 3 + 2) >= ll
                    array.set(supres, y * 3, -1)

            src += 1
            if src >= 10
                break

    for x = 0 to 8 by 1
        for y = x + 1 to 9 by 1
            if array.get(stren, y) > array.get(stren, x)
                tmp = array.get(stren, y)
                array.set(stren, y, array.get(stren, x))
                changeit(x, y)


get_level(ind) =>
    float ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind)
            ret
    ret

get_color(ind) =>
    color ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind) > close and array.get(suportresistance, ind + 1) > close ? res_col : array.get(suportresistance, ind) < close and array.get(suportresistance, ind + 1) < close ? sup_col : inch_col
            ret
    ret

var srchannels = array.new_box(10)
for x = 0 to math.min(9, maxnumsr) by 1
    box.delete(array.get(srchannels, x))
    srcol = get_color(x * 2)
    if not na(srcol)
        array.set(srchannels, x, box.new(left=bar_index, top=get_level(x * 2), right=bar_index + 1, bottom=get_level(x * 2 + 1), border_color=srcol, border_width=1, extend=extend.both, bgcolor=srcol))

resistancebroken = false
supportbroken = false

// check if it's not in a channel
not_in_a_channel = true
for x = 0 to math.min(9, maxnumsr) by 1
    if close <= array.get(suportresistance, x * 2) and close >= array.get(suportresistance, x * 2 + 1)
        not_in_a_channel := false
        not_in_a_channel

// if price is not in a channel then check broken ones
if not_in_a_channel
    for x = 0 to math.min(9, maxnumsr) by 1
        if close[1] <= array.get(suportresistance, x * 2) and close > array.get(suportresistance, x * 2)
            resistancebroken := true
            resistancebroken
        if close[1] >= array.get(suportresistance, x * 2 + 1) and close < array.get(suportresistance, x * 2 + 1)
            supportbroken := true
            supportbroken

alertcondition(resistancebroken, title='Resistance Broken', message='Resistance Broken')
alertcondition(supportbroken, title='Support Broken', message='Support Broken')
plotshape(showsrbroken and resistancebroken, style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
plotshape(showsrbroken and supportbroken, style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny)



//
//
//
//
//
//


sslsignals=input.string(title='Buy Sell Signals', defval='SSL-HYBRID', options=['SSL-HYBRID', 'SSL+QQE+WAE','SSL-HYBRID+SuperTrend'], group='Settings: Signals',inline='Filter')
strend=input.string(title='Filter Buy Sell Signals', defval='NO-FILTER', options=['NO-FILTER', 'SUPERTREND','HULL'], group='Settings: Signals',inline='Filter')
squeezesignalfilter= input(false, title='Remove Alerts & Signals at BB-Squeeze',group='Settings: Signals',inline='Filter')
//stbs=input.bool(true,'Add Supertrend Buy/Sell',group='Settings: Signals',inline='filter')
adxsignalfilter= input(false, title='Remove Alerts & Signals at LOW ADX/SIDEWAYS',group='Settings: Signals',inline='Filter')
strengthtreshold=input(8, 'Table Alert Strength', group='Strategy: Table Strength',inline='table')
showtable=input.bool(true,'Show SSL Table', group='Strategy: Table Strength',inline='table')
showtable2=input.bool(true,'Show Strength Table', group='Strategy: Table Strength',inline='table')
//applystrength=input.bool(false,'Apply Strength to HMA', group='Strategy: Table Strength',inline='table')
show_ema200=input.bool(false,title='show Ema200 with ADX', group='Settings: Indicators')
showbbsqueeze = input(true, title='Show Bollinger Squeeze', group='Settings: Indicators')
showadxbg=input.bool(true,title='show Low ADX as Background',group='Candles')
showadxcandles=input.bool(true,title='show Low ADX Candles',group='Candles')
showbb=input.string('BB', title='Show Bollinger/Keltner Band',options=['--','BB','Keltner'],group='Settings: Indicators')
showmtfma=input.bool(false,title='Show MTF EMA', group='Settings: Indicators')
showqqedot = input.bool(true,title='Show QQE MOD Support', group='Settings: Indicators')
showbg = input.bool(true,title='QQE Signal Background', group='Settings: Indicators')
qqeline=input(title='QQE Line', defval=false, group='Settings: Indicators')
showppssl = input(false, title='Show Pivot Points', group='Settings: Indicators')
showsr=input(false, title='Show Support Resistance', group='Settings: Indicators')
show_Baseline = input(title='Show SSL Baseline', defval=true, group='SSL')
show_SSL1 = input(title='Show SSL1 Support', defval=false, group='SSL')
showssl2=input(title='Show SSL2 Support', defval=false,group='SSL')
show_atr = input(title='Show ATR bands', defval=false, group='Settings: ATR')

//ATR
atrlen = input(14, 'ATR Period', group='Settings: ATR')
mult = input.float(1.5, 'ATR Multi', step=0.1, group='Settings: ATR')
smoothing = input.string(title='ATR Smoothing', defval='WMA', options=['RMA', 'SMA', 'EMA', 'WMA'], group='Settings: ATR')

ma_function(source, atrlen) =>
    if smoothing == 'RMA'
        ta.rma(source, atrlen)
    else
        if smoothing == 'SMA'
            ta.sma(source, atrlen)
        else
            if smoothing == 'EMA'
                ta.ema(source, atrlen)
            else
                ta.wma(source, atrlen)
atr_slen = ma_function(ta.tr(true), atrlen)
////ATR Up/Low Bands
upper_band = atr_slen * mult + close
lower_band = close - atr_slen * mult

////BASELINE / SSL1 / SSL2 / EXIT MOVING AVERAGE VALUES
maType = input.string(title='SSL1 / Baseline Type', defval='HMA', options=['ZLSMA','SMA', 'EMA', 'DEMA', 'TEMA', 'LSMA', 'WMA', 'MF', 'VAMA', 'TMA', 'HMA', 'JMA', 'Kijun v2', 'EDSMA', 'McGinley'], group='Settings: SSL')
len = input(title='SSL1 / Baseline Length', defval=55, group='Settings: SSL')

SSL2Type = input.string(title='SSL2 / Continuation Type', defval='JMA', options=['SMA', 'EMA', 'DEMA', 'TEMA', 'WMA', 'MF', 'VAMA', 'TMA', 'HMA', 'JMA', 'McGinley'], group='Settings: SSL')
len2 = input(title='SSL 2 Length', defval=5, group='Settings: SSL')
//
SSL3Type = input.string(title='EXIT Type', defval='HMA', options=['DEMA', 'TEMA', 'LSMA', 'VAMA', 'TMA', 'HMA', 'JMA', 'Kijun v2', 'McGinley', 'MF'], group='Settings: SSL')
len3 = input(title='EXIT Length', defval=15)
src = input(title='Source', defval=close)

//
tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    3 * ema1 - 3 * ema2 + ema3
kidiv = input.int(defval=1, maxval=4, title='Kijun MOD Divider', group='Settings: SSL')

jurik_phase = input(title='* Jurik (JMA) Only - Phase', defval=3, group='Settings: SSL')
jurik_power = input(title='* Jurik (JMA) Only - Power', defval=1, group='Settings: SSL')
volatility_lookback = input(10, title='* Volatility Adjusted (VAMA) Only - Volatility lookback length', group='Settings: SSL')
//MF
beta = input.float(0.8, minval=0, maxval=1, step=0.1, title='Modular Filter, General Filter Only - Beta', group='Settings: SSL')
feedback = input(false, title='Modular Filter Only - Feedback', group='Settings: SSL')
z = input.float(0.5, title='Modular Filter Only - Feedback Weighting', step=0.1, minval=0, maxval=1, group='Settings: SSL')
//EDSMA
ssfLength = input.int(title='EDSMA - Super Smoother Filter Length', minval=1, defval=20, group='Settings: SSL')
ssfPoles = input.int(title='EDSMA - Super Smoother Filter Poles', defval=2, options=[2, 3], group='Settings: SSL')

//----

//EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * math.asin(1)
    arg = math.sqrt(2) * PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(arg)
    c2 = b1
    c3 = -math.pow(a1, 2)
    c1 = 1 - c2 - c3

    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])
    ssf

get3PoleSSF(src, length) =>
    PI = 2 * math.asin(1)

    arg = PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(1.738 * arg)
    c1 = math.pow(a1, 2)

    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = math.pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4

    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])
    ssf

ma(type, src, len) =>
    float result = 0
    if type == 'TMA'
        result := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)
        result
    if type == 'MF'
        ts = 0.
        b = 0.
        c = 0.
        os = 0.
        //----
        alpha = 2 / (len + 1)
        a = feedback ? z * src + (1 - z) * nz(ts[1], src) : src
        //----
        b := a > alpha * a + (1 - alpha) * nz(b[1], a) ? a : alpha * a + (1 - alpha) * nz(b[1], a)
        c := a < alpha * a + (1 - alpha) * nz(c[1], a) ? a : alpha * a + (1 - alpha) * nz(c[1], a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta * b + (1 - beta) * c
        lower = beta * c + (1 - beta) * b
        ts := os * upper + (1 - os) * lower
        result := ts
        result
    if type == 'LSMA'
        result := ta.linreg(src, len, 0)
        result
    if type == 'SMA'  // Simple
        result := ta.sma(src, len)
        result
    if type == 'EMA'  // Exponential
        result := ta.ema(src, len)
        result
    if type == 'DEMA'  // Double Exponential
        e = ta.ema(src, len)
        result := 2 * e - ta.ema(e, len)
        result
    if type == 'TEMA'  // Triple Exponential
        e = ta.ema(src, len)
        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)
        result
    if type == 'WMA'  // Weighted
        result := ta.wma(src, len)
        result
    if type == 'VAMA'  // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid = ta.ema(src, len)
        dev = src - mid
        vol_up = ta.highest(dev, volatility_lookback)
        vol_down = ta.lowest(dev, volatility_lookback)
        result := mid + math.avg(vol_up, vol_down)
        result
    if type == 'HMA'  // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
        result
    if type == 'JMA'  // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = math.pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
        result
    if type == 'Kijun v2'
        kijun = math.avg(ta.lowest(len), ta.highest(len))  //, (open + close)/2)
        conversionLine = math.avg(ta.lowest(len / kidiv), ta.highest(len / kidiv))
        delta = (kijun + conversionLine) / 2
        result := delta
        result
    if type == 'McGinley'
        mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src / mg[1], 4))
        result := mg
        result
    if type == 'EDSMA'

        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2

        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2 ? get2PoleSSF(avgZeros, ssfLength) : get3PoleSSF(avgZeros, ssfLength)

        // Rescale filter in terms of Standard Deviations
        stdev = ta.stdev(ssf, len)
        scaledFilter = stdev != 0 ? ssf / stdev : 0

        alpha = 5 * math.abs(scaledFilter) / len

        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result := edsma
        result
    if type == 'ZLSMA'
        lsma = ta.linreg(src, len, 0)
        lsma2 = ta.linreg(lsma, len, 0)
        eq= lsma-lsma2
        result := lsma+eq
        result
    result

///SSL 1 and SSL2
emaHigh = ma(maType, high, len)
emaLow = ma(maType, low, len)

maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)

///EXIT
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)

///Keltner Baseline Channel
BBMC = ma(maType, close, len)
useTrueRange = input(true)
multy = input.float(0.2, step=0.05, title='Base Channel Multiplier', group='Settings: SSL')
Keltma = ma(maType, src, len)
range_1 = useTrueRange ? ta.tr : high - low
rangema = ta.ema(range_1, len)
upperk = Keltma + rangema * multy
lowerk = Keltma - rangema * multy

//Baseline Violation Candle
open_pos = open * 1
close_pos = close * 1
difference = math.abs(close_pos - open_pos)
atr_violation = difference > atr_slen
InRange = upper_band > BBMC and lower_band < BBMC
candlesize_violation = atr_violation and InRange
//plotshape(candlesize_violation, color=color.new(color.white, 0), size=size.tiny, style=shape.diamond, location=location.top, title='Candle Size > 1xATR')

//SSL1 VALUES
Hlv = int(na)
Hlv := close > emaHigh ? 1 : close < emaLow ? -1 : Hlv[1]
sslDown = Hlv < 0 ? emaHigh : emaLow

//SSL2 VALUES
Hlv2 = int(na)
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow

//EXIT VALUES
Hlv3 = int(na)
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
base_cross_Long = ta.crossover(close, sslExit)
base_cross_Short = ta.crossover(sslExit, close)
codiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na

//COLORS
show_color_bar = input(title='Color Bars', defval=true, group='Candles')
color_bar = close > upperk ?color.new( #00c3ff,0) : close < lowerk ? color.new(#ff0062,0) : color.new(color.gray,0)
color_ssl1 = close > sslDown ?color.new( #00c3ff,0) : close < sslDown ? color.new(#ff0062,0) :na
color_bar2=close > upperk ? color.new(#0000ff,0) : close < lowerk ? color.new(#ff0000,0) : color.new(color.gray,0)
//PLOTS
plotarrow(codiff, colorup=color.new(#00c3ff, 20), colordown=color.new(#ff0062, 20), title='Exit Arrows', maxheight=20, offset=0)

DownPlot = plot(show_SSL1 ? sslDown : na, title='SSL1', linewidth=3, color=color_ssl1)
//up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title='Baseline Upper Channel')
//low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title='Baseline Lower Channel')
//fill(up_channel, low_channel, color=color_bar, transp=90)
//plotshape(sslsignals and ta.crossover(close,sslExit), title='SSL Buy', text='Buy', location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(#00c3ff, 50), textcolor=color.new(color.white, 0))
//plotshape(sslsignals and ta.crossover(sslExit,close), title='SSL Sell', text='Sell', location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(#ff0062, 50), textcolor=color.new(color.white, 0))

////SSL2 Continiuation from ATR
atr_crit = input.float(0.9, step=0.1, title='Continuation ATR Criteria', group='Settings: SSL')
upper_half = atr_slen * atr_crit + close
lower_half = close - atr_slen * atr_crit
buy_inatr = lower_half < sslDown2
sell_inatr = upper_half > sslDown2
sell_cont = close < BBMC and close < sslDown2
buy_cont = close > BBMC and close > sslDown2
sell_atr = sell_inatr and sell_cont
buy_atr = buy_inatr and buy_cont
atr_fill = buy_atr ? color.new(color.green,0) : sell_atr ? color.new(color.purple,0) : color.new(color.white,0)
LongPlot = plot(showssl2?sslDown2:na, title='SSL2', linewidth=2, color=atr_fill, style=plot.style_circles)
u = plot(show_atr ? upper_band : na, '+ATR', color=color.new(color.rgb(0, 255, 0, 50), 80),linewidth=2)
l = plot(show_atr ? lower_band : na, '-ATR', color=color.new(color.rgb(255, 0, 0, 50), 80),linewidth=2)
//plot(BBMC,color=color.yellow,linewidth=4,title='BBMC')


///QQE MOD
RSI_Period = input(6, title='RSI Length',group='Settings:QQE-MOD')
SF = input(5, title='RSI Smoothing',group='Settings:QQE-MOD')
QQE = input.float(3, title='Fast QQE Factor',group='Settings:QQE-MOD',step=0.1)
ThreshHold = input(3, title='Thresh-hold',group='Settings:QQE-MOD')
qqsrc = input(close, title='RSI Source',group='Settings:QQE-MOD')
Wilders_Period = RSI_Period * 2 - 1
Rsi = ta.rsi(qqsrc, RSI_Period)
RsiMa = ta.ema(Rsi, SF)
AtrRsi = math.abs(RsiMa[1] - RsiMa)
MaAtrRsi = ta.ema(AtrRsi, Wilders_Period)
dar = ta.ema(MaAtrRsi, Wilders_Period) * QQE
longband = 0.0
shortband = 0.0
trend = 0
DeltaFastAtrRsi = dar
RSIndex = RsiMa
newshortband = RSIndex + DeltaFastAtrRsi
newlongband = RSIndex - DeltaFastAtrRsi
longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? math.max(longband[1], newlongband) : newlongband
shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? math.min(shortband[1], newshortband) : newshortband
cross_1 = ta.cross(longband[1], RSIndex)
trend := ta.cross(RSIndex, shortband[1]) ? 1 : cross_1 ? -1 : nz(trend[1], 1)
FastAtrRsiTL = trend == 1 ? longband : shortband
////////////////////
length = input.int(50, minval=1, title='Bollinger Length',group='Settings:QQE-MOD')
qqmult = input.float(0.35, minval=0.001, maxval=5, step=0.1, title='BB Multiplier',group='Settings:QQE-MOD')
basis = ta.sma(FastAtrRsiTL - 50, length)
dev = qqmult * ta.stdev(FastAtrRsiTL - 50, length)
upper = basis + dev
lower = basis - dev
qqcolor_bar = RsiMa - 50 > upper ?color.new( #00c3ff,0) : RsiMa - 50 < lower ? color.new(#ff0062,0) : color.new(color.gray,0)
// Zero cross
QQEzlong = 0
QQEzlong := nz(QQEzlong[1])
QQEzshort = 0
QQEzshort := nz(QQEzshort[1])
QQEzlong := RSIndex >= 50 ? QQEzlong + 1 : 0
QQEzshort := RSIndex < 50 ? QQEzshort + 1 : 0
//Zero = hline(0, color=color.white, linestyle=hline.style_dotted, linewidth=1)
////////////////////////////////////////////////////////////////
RSI_Period2 = input(6, title='RSI Length',group='Settings:QQE-MOD')
SF2 = input(5, title='RSI Smoothing',group='Settings:QQE-MOD')
QQE2 = input.float(1.61, title='Fast QQE2 Factor',group='Settings:QQE-MOD',step=0.1)
ThreshHold2 = input(3, title='Threshold',group='Settings:QQE-MOD')
src2ssl = input(close, title='RSI Source',group='Settings:QQE-MOD')
Wilders_Period2 = RSI_Period2 * 2 - 1
Rsi2 = ta.rsi(src2ssl, RSI_Period2)
RsiMa2 = ta.ema(Rsi2, SF2)
AtrRsi2 = math.abs(RsiMa2[1] - RsiMa2)
MaAtrRsi2 = ta.ema(AtrRsi2, Wilders_Period2)
dar2 = ta.ema(MaAtrRsi2, Wilders_Period2) * QQE2
longband2 = 0.0
shortband2 = 0.0
trend2 = 0
DeltaFastAtrRsi2 = dar2
RSIndex2 = RsiMa2
newshortband2 = RSIndex2 + DeltaFastAtrRsi2
newlongband2 = RSIndex2 - DeltaFastAtrRsi2
longband2 := RSIndex2[1] > longband2[1] and RSIndex2 > longband2[1] ? math.max(longband2[1], newlongband2) : newlongband2
shortband2 := RSIndex2[1] < shortband2[1] and RSIndex2 < shortband2[1] ? math.min(shortband2[1], newshortband2) : newshortband2
cross_2 = ta.cross(longband2[1], RSIndex2)
trend2 := ta.cross(RSIndex2, shortband2[1]) ? 1 : cross_2 ? -1 : nz(trend2[1], 1)
FastAtrRsi2TL = trend2 == 1 ? longband2 : shortband2
// Zero cross
QQE2zlong = 0
QQE2zlong := nz(QQE2zlong[1])
QQE2zshort = 0
QQE2zshort := nz(QQE2zshort[1])
QQE2zlong := RSIndex2 >= 50 ? QQE2zlong + 1 : 0
QQE2zshort := RSIndex2 < 50 ? QQE2zshort + 1 : 0
hcolor2 = RsiMa2 - 50 > ThreshHold2 ? color.new(#161b25,0): RsiMa2 - 50 < 0 - ThreshHold2 ? color.new(#161b25,0): color.new(#161b25,0)
//plot(ta.ema( close+(FastAtrRsi2TL-50)/10000,5), title='QQE Line', color=color.new(color.gray, 0), linewidth=2)
//plot(RsiMa2 - 50, color=hcolor2, title='Histo2', style=plot.style_columns, transp=50)
Greenbar1 = RsiMa2 - 50 > ThreshHold2
Greenbar2 = RsiMa - 50 > upper
Redbar1 = RsiMa2 - 50 < 0 - ThreshHold2
Redbar2 = RsiMa - 50 < lower
//plot(Greenbar1 and Greenbar2 == 1 ? RsiMa2 - 50 : na, title='QQE Up', style=plot.style_columns, color=color.new(#00c3ff, 0))
//plot(Redbar1 and Redbar2 == 1 ? RsiMa2 - 50 : na, title='QQE Down', style=plot.style_columns, color=color.new(#ff0062, 0))
//bgcolor(showbg and RsiMa2 - 50?hcolor2:na,title='QQE Bg GREY')
qqcolr=FastAtrRsiTL-50<RsiMa-50? color.new(#002734, 0):FastAtrRsiTL-50>RsiMa-50? color.new(#3a0016, 0): na
bgcolor(showbg ?qqcolr:na,title='QQE Bg')

//--->plotshape(showqqedot?Greenbar1 and Greenbar2:na,color=color.new(#00c3ff, 20),title='QQE Up',style=shape.triangleup,size=size.auto,location=location.belowbar)
//--->plotshape(showqqedot?Redbar1 and Redbar2:na,color=color.new(#ff0062, 20),title='QQE Dn',style=shape.triangledown,size=size.auto,location=location.abovebar)


//plotarrow(codiff, colorup=color.new(#00c3ff, 20), colordown=color.new(#ff0062, 20), title='Exit Arrows', maxheight=20, offset=0)
//hcolor2 = RsiMa2 - 50 > ThreshHold2 ? color.silver : RsiMa2 - 50 < 0 - ThreshHold2 ? color.silver : na
qqecolor=Greenbar1 and Greenbar2 == 1 and RsiMa2 - 50? color.new(#00c3ff, 0):Redbar1 and Redbar2 == 1 and RsiMa2 - 50 ? color.new(#ff0062, 0):color.new(color.gray, 0)
plot(qqeline?ta.ema( close+(FastAtrRsi2TL-50)/10000,5):na, title='QQE Line', color=qqecolor, linewidth=2)

qqxcolor=FastAtrRsiTL-50<RsiMa-50?color.new(color.green,0):FastAtrRsiTL-50>RsiMa-50?color.new(color.red,0):na
//p2=plot(FastAtrRsiTL-50,color=color.red,transp=0,linewidth=2)
//p1=plot(RsiMa-50,color=color.green,transp=0,linewidth=2)

sensitivity = input.int(150, title="Sensitivity", group='Indicators: Waddah Attar Explosion')
fastLength=input.int(20, title="FastEMA Length", group='Indicators: Waddah Attar Explosion')
slowLength=input.int(40, title="SlowEMA Length", group='Indicators: Waddah Attar Explosion')
channelLength=input.int(20, title="BB Channel Length", group='Indicators: Waddah Attar Explosion')
waeMult=input.float(2.0, title="BB Stdev Multiplier", group='Indicators: Waddah Attar Explosion')

calc_macd(source, fastLength, slowLength) =>
	fastMA = ta.ema(source, fastLength)
	slowMA = ta.ema(source, slowLength)
	fastMA - slowMA

calc_BBUpper(source, length, mult) => 
	basis = ta.sma(source, length)
	dev = mult * ta.stdev(source, length)
	basis + dev

calc_BBLower(source, length, mult) => 
	basis = ta.sma(source, length)
	dev = mult * ta.stdev(source, length)
	basis - dev

t1 = (calc_macd(close, fastLength, slowLength) - calc_macd(close[1], fastLength, slowLength))*sensitivity

e1 = (calc_BBUpper(close, channelLength, waeMult) - calc_BBLower(close, channelLength, waeMult))

trendUp = (t1 >= 0) ? t1 : 0
trendDown = (t1 < 0) ? (-1*t1) : 0
// Waddah Attar Explosion
waeBuy = trendUp > 0 and trendUp > e1
waeSell = trendDown > 0 and trendDown > e1
waecol=waeBuy?color.new(#00c3ff,0) :waeSell?color.new(#ff0062,0):color.new(color.gray,0)
//plot(trendUp, style=plot.style_columns, linewidth=1, color=(trendUp<trendUp[1]) ? color.lime : color.green, transp=45, title="UpTrend", display=display.none)
//plot(trendDown, style=plot.style_columns, linewidth=1, color=(trendDown<trendDown[1]) ? color.orange : color.red, transp=45, title="DownTrend", display=display.none)
//plot(e1, style=plot.style_line, linewidth=2, color=color.yellow, title="ExplosionLine", display=display.none)

///////////ADX
adxl=input(14, title='ADX/DMI length', group='Settings: ADX')
adxs=input(14, title='ADX/DMI smooth length', group='Settings: ADX')
[plus,minus,adx]=request.security(syminfo.tickerid,'',ta.dmi(adxl,adxs))
adxtreshold=input.int(20,'ADX Treshold', group='Settings: ADX')
em200=ta.ema(open,200)
adxem200color=adx>adxtreshold and plus>minus?color.new(color.lime, 0):adx>adxtreshold and plus<minus?color.new(color.maroon, 0):color.new(color.yellow, 0)
plot(show_ema200 ? em200 : na, 'EMA200', color=adxem200color,linewidth=3,title='ADX Cross')
adxcross=ta.crossover(plus,minus)?color.new(color.blue, 0):ta.crossunder(plus,minus)?color.new(color.red, 0):na
plotshape(ta.cross(plus,minus)?em200:na, color=adxcross, size=size.tiny,location=location.absolute, style=shape.diamond, title='ADX Cross')
///////////////////HULL+SUPRTREND
showhulltrend=input.bool(false,'Show HULL MTF',  group='Settings: Filters',inline='HULL')
showtrend=input.bool(false,'Show Supertrend', group='Settings: Filters',inline='Supertrend')
showstc=input.bool(true,title='SuperTrend Color/Hull Color',  group='Settings: Filters',inline='Supertrend')
mtf4 = input.timeframe(title="HULL TIME FRAME",  defval="",  group='Settings: Filters',inline='HULL')
stf4 = input.timeframe(title="SUPER TREND TIME FRAME",  defval="",  group='Settings: Filters',inline='Supertrend')
ma_length4 = input(110, title = "Hull TREND Length\n[Scalping:55,Floating S/R:100-300,]",  group='Settings: Filters',inline='HULL')

ma4 = request.security(syminfo.tickerid, mtf4,ta.hma(close, ma_length4),barmerge.gaps_on)
color4=open>ma4?color.new(#00ff00,0):open<ma4?color.new(#ff0000,0):color.new(color.gray,0)
pl4 = plot(showhulltrend?ma4:na, title="MTF HULL TREND", color=color4, linewidth=4, offset=0)

[supertrend,direction]=request.security(syminfo.tickerid, stf4,ta.supertrend(input.float(3,title='Supertrend ATR Multiplier',step=0.1,  group='Settings: Filters',inline='Supertrend'),input.int(10,title='Supertrend Length',  group='Settings: Filters',inline='Supertrend')),barmerge.gaps_off)
supertrendup=direction<0?supertrend:na
supertrenddn=direction>0?supertrend:na
stc=supertrendup?color.new(#00c3ff,50):color.new(#ff0062,50)
trendcolor=showstc?stc:qqxcolor
plot(showtrend?supertrendup:na,title='Supertrend Up',color=trendcolor,linewidth=4,style=plot.style_linebr)
plot(showtrend?supertrenddn:na,title='Supertrend Down',color=trendcolor,linewidth=4,style=plot.style_linebr)

///////////////MACD///////////
[macd,signal,hist]=ta.macd(close,input.int(5,title='FAST MACD',group='Settings: MACD'),input.int(50,title='SLOW MACD',group='Settings: MACD'),input.int(30,title='Signal',group='Settings: MACD'))
plotshape(ta.crossover(macd,signal)?close:na, title='MACD Crossover Buy', text='', location=location.belowbar, style=shape.xcross, size=size.tiny, color=color.new(#00FF00, 20), textcolor=color.new(color.white, 0))
plotshape(ta.crossunder(macd,signal)?close:na, title='MACD Crossover Sell', text='', location=location.abovebar, style=shape.xcross, size=size.tiny, color=color.new(#ff0000, 0), textcolor=color.new(color.white, 0))
color_bars=showadxbg and adx<adxtreshold?color.new(color.purple,90):na
bgcolor(adx<adxtreshold ? color_bars : na)
/////////////
/////////////////////////Bollinger Bands
matype=input.string('SMA',title='Bollinger MA type',options=['EMA','HMA','SMA'])
kLength = input(20, title='Keltner Length')
kN = input(2, title='Keltner Deviation')
bbLength = input(20, title='Bollinger Length')
bbN = input(2, title='Bollinger Deviation')
//--- Keltner
kma=matype=='EMA'?ta.ema(close, kLength):matype=='HMA'?ta.hma(close, kLength):ta.sma(close, kLength)
kUpper = kma + kN * ta.atr(kLength)
kLower = kma - kN * ta.atr(kLength)
//--- Bollinger
bma=matype=='EMA'?ta.ema(close, bbLength):matype=='HMA'?ta.hma(close, bbLength):ta.sma(close, bbLength)
bbUpper = bma + bbN * ta.stdev(close, bbLength)
bbLower = bma - bbN * ta.stdev(close, bbLength)
bbMiddle=matype=='EMA'?ta.ema(close, bbLength):matype=='HMA'?ta.hma(close, bbLength):ta.sma(close, bbLength)
//--- Bollinger Band Squeeze
squeeze = bbUpper <= kUpper and bbLower >= kLower
//--- Plots
//plot(bbUpper, title='Upper Band')
//plot(bbLower, title='Lower Band')
//--- Fill

plot(showbb=='BB'?bbUpper:showbb=='Keltner'?kUpper:na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Upper Band')
plot(showbb=='BB'?bbLower:showbb=='Keltner'?kLower:na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Lower Band')
//plot(showbb=='BB'?ta.sma(close,20):showbb=='Keltner'?ta.sma(close,20):na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Middle Band')
a = plot(squeeze and showbbsqueeze? bbUpper : na, style=plot.style_linebr, color=bar_index ? na : color.new(color.white, 0), title='Squeezed Upper Band')
b = plot(squeeze and showbbsqueeze? bbLower : na, style=plot.style_linebr, color=bar_index ? na : color.new(color.white, 0), title='Squeezed Lower Band')
fill(a, b, color=color.new(color.purple, 90), title='Bollinger Squeezed Area')
//////////
///////////////Multi Time Frame EMA
mtf1 = input.timeframe(title="EMA MTF1",  defval="", group='Settings: EMA')
mtf2 = input.timeframe(title="EMA MTF2",  defval="", group='Settings: EMA')
ma_length1 = input(20, title = "EMA Period-1", group='Settings: EMA')
ma_length2 = input(50, title = "EMA Period-2", group='Settings: EMA')
ma1ssl = request.security(syminfo.tickerid, mtf1,  ta.ema(close, ma_length1),barmerge.gaps_on)
color1=open>ma1?color.new(#00FF00,60):open<ma1?color.new(#00FF00,60):color.new(color.gray,0)

pl1 = plot(showmtfma?ma1ssl:showbb=='BB'?bbMiddle:showbb=='Keltner'?bbMiddle:na, title="MTF EMA-1", color=showmtfma and ma1ssl?color1:color.purple , linewidth=1, offset=0)

ma2ssl = request.security(syminfo.tickerid, mtf2,ta.ema(close, ma_length2),barmerge.gaps_on)
color2=open>ma2ssl?color.new(#ff0000,60):open<ma2ssl?color.new(#ff0000,60):color.new(color.gray,0)

pl2 = plot(showmtfma?ma2:na, title="MTF EMA-2", color=color2, linewidth=1, offset=0)

plotshape(ta.crossover(ma1ssl,ma2ssl)?close:na, title='EMA Crossover Buy', text='', location=location.belowbar, style=shape.xcross, size=size.tiny, color=color.new(#00FF00, 20), textcolor=color.new(color.white, 0))
plotshape(ta.crossunder(ma1ssl,ma2ssl)?close:na, title='EMA Crossover Sell', text='', location=location.abovebar, style=shape.xcross, size=size.tiny, color=color.new(#ff0000, 50), textcolor=color.new(color.white, 0))
//////////////////
rsi()=>
    srce = close
    len = input.int(7, minval=1, title='RSI Length', group='RSI')
    srs = input.int(18, minval=1, title='RSI SMA Length', group='RSI')
    up = ta.rma(math.max(ta.change(srce), 0), len)
    down = ta.rma(-math.min(ta.change(srce), 0), len)
    rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)
    //mr = ta.ema(ta.ema(rsi, srs), srs)
    mr = ta.ema(ta.ema(ta.ema(rsi,srs), srs), srs)
    rsiupdn=rsi>mr?1:rsi<mr?-1:0
    [rsiupdn]

cci()=>
    ccilength = input.int(40, minval=1,title='CCI Length',group='CCI')
    ccisrc = input(hlc3, title="CCI Source",group='CCI')
    ccima = ta.sma(ccisrc, ccilength)
    cci = (ccisrc - ccima) / (0.015 * ta.dev(ccisrc, ccilength))
    ccibg= cci>100?1:cci<-100?-1:0
    [ccibg]
sto()=>
    OverBought = input(80,title='Stochastic OverBought Level',group='stochastic')
    OverSold = input(20,title='Stochastic OverBought Level',group='stochastic')
    k = ta.sma(ta.stoch(close, high, low, input.int(14, minval=1,title='Stochastic Length',group='stochastic')), input.int(3, minval=1,title='Stochastic Smooth Length K',group='stochastic'))
    d = ta.sma(k, input.int(3, minval=1,title='Stochastic Deviation Length D',group='stochastic'))
    co = ta.crossover(k,d)
    cu = ta.crossunder(k,d)
    sup=k > OverBought or cu and k > OverBought
    sdn=k < OverSold or co and  k < OverSold
    stobg=sup?1:sdn?-1:co?2:cu?-2:0
    [stobg]
start = input.float(title="PSAR Start",  step=0.001, defval=0.02, group="PSAR")
increment = input.float(title="PSAR Increment",  step=0.001, defval=0.02, group="PSAR")
maximum = input.float(title="PSAR Maximum", step=0.01, defval=0.2, group="PSAR")
psar = ta.sar(start, increment, maximum)
psarDir = psar < close ? 1 : -1
colorPSAR = psarDir == 1 ? color.new(#00c3ff,0) : color.new(#ff0062,0) //color_bar

exitsig = close > upperk and close > BBMC ?  color.new(#00c3ff,0) : close < lowerk and close < BBMC? color.new(#ff0062,0)  :color.new(color.gray,0)
qqedot=Greenbar1 and Greenbar2 and waeBuy? color.new(#00c3ff,0) : Redbar1 and Redbar2 and waeSell?color.new(#ff0062,0):color.new(color.gray,0)

adxcol=adx>20 and plus>minus?color.new(#00c3ff,0) :adx>20 and minus>plus?color.new(#ff0062,0):color.new(color.gray,0)
emacol=ta.crossover(ma1,ma2) or close>ma2 ? color.new(#00c3ff,0) :ta.crossunder(ma1,ma2) or close<ma2?color.new(#ff0062,0):color.new(color.gray,0)

psarn=psarDir == 1 ? 1 : -1 //PSAR VALUE
exitsign=close > upperk and close > 1 ?  1 : close < lowerk and close < BBMC? -1  : 0
qqedotn=Greenbar1 and Greenbar2 and waeBuy?1 : Redbar1 and Redbar2 and waeSell?-1:0
adxcoln=adx>20 and plus>minus?1 :adx>20 and minus>plus?-1:0
emacoln=ta.crossover(ma1,ma2) or close>ma2 ? 1 :ta.crossunder(ma1ssl,ma2ssl) or close<ma2?-1:0
waen=waeBuy?1:waeSell?-1:0
stval=direction<0 ?1:direction>0?-1:0
//SSL TABLE
[sto]=sto()
[rs]=rsi()
[cc]=cci()
stocol=sto>0 ? color.new(#00c3ff,0) :sto<0 ?color.new(#ff0062,0):color.new(color.gray,0)
rsicol=rs>0 ? color.new(#00c3ff,0) :rs<0 ?color.new(#ff0062,0):color.new(color.gray,0)
ccicol=cc>0 ? color.new(#00c3ff,0) :cc<0 ?color.new(#ff0062,0):color.new(color.gray,0)
sttrend=direction<0 ? color.new(#00c3ff,0) :direction>0?color.new(#ff0062,0):color.new(color.gray,0)
///////////Strategy Signals
qqeGreenBar = Greenbar1 and Greenbar2
qqeRedBar = Redbar1 and Redbar2
qqeBuy = qqeGreenBar and not qqeGreenBar[1]
qqeSell = qqeRedBar and not qqeRedBar[1]
p1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4, title='MA Baseline')
barcolor(show_color_bar ? color_bar :
         show_color_bar and adx<adxtreshold and showadxcandles ?color.new(color.yellow,90):
         na)
plotshape(showqqedot?qqeGreenBar:na,color=color.new(#00ff00, 20),title='QQE Up',style=shape.triangleup,size=size.auto,location=location.belowbar)
plotshape(showqqedot?qqeRedBar:na,color=color.new(#ff0000, 20),title='QQE Dn',style=shape.triangledown,size=size.auto,location=location.abovebar)
// SSL Hybrid
sslBuy = close > upperk and close > BBMC
sslSell = close < lowerk and close < BBMC
//STRATEGY
stratsslupsig=waeBuy and qqeBuy and sslBuy 
stratssldnsig=waeSell and qqeSell and sslSell 
//SSL HYBRID
sslup=ta.crossover(close,sslExit)
ssldn=ta.crossover(sslExit,close)
//SUPERTREND
strendup = direction<0 and ta.change(direction)  
strenddn = direction>0 and ta.change(direction) 
//SSL+SUPERTREND
sslupst=ta.crossover(close,sslExit) or strendup
ssldnst=ta.crossover(sslExit,close) or strenddn
//HMA DIRECTION
hmadirection=close>ma4?1:close<ma4?-1:0
signalup= strend=='NO-FILTER' and sslsignals=='SSL-HYBRID'?sslup:
          strend=='NO-FILTER' and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='NO-FILTER' and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          na
signalup:=squeezesignalfilter and squeeze?na:signalup
signalup:=adxsignalfilter and adx<adxtreshold?na:signalup

signaldn= strend=='NO-FILTER' and sslsignals=='SSL-HYBRID'?ssldn:
          strend=='NO-FILTER' and sslsignals=='SSL+QQE+WAE' ? stratssldnsig:
          strend=='NO-FILTER' and sslsignals=='SSL-HYBRID+SuperTrend'?ssldnst:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL-HYBRID'?ssldn:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL+QQE+WAE'?stratssldnsig:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL-HYBRID+SuperTrend'?ssldnst:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          na
signaldn:=squeezesignalfilter and squeeze?na:signaldn
signaldn:=adxsignalfilter and adx<adxtreshold?na:signaldn

plotshape(signalup, title='SSL Buy', text='Buy', location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(#00c3ff, 50), textcolor=color.new(color.white, 0))
plotshape(signaldn, title='SSL Sell', text='Sell', location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(#ff0062, 50), textcolor=color.new(color.white, 0))
